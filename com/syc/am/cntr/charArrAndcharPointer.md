1.  以字符串形式出现的,编译器会在结尾自动添加'\0',思考,为什么?
  存在的C语言方法,如strlen(s),计算字符串的长度,其中s指针.strlen要计算字符串长度,必须知道哪里是结尾,因此使用\0表示结尾.只有字符数组才有\0的概念,其它类型(int)的数组没有这个概念.因为其他类型的数组或者指针,没有strlen这种方法.
  那么问题来了,int数组如何计算长度呢?如int a1 = {3,7,9,};
  使用sizeof(a1)/sizeof(int).
2.  数组可以在栈上分配,也可以在堆上分配,但必须指定大小.
  char a1[100]; //在栈上分配
  char* pa = new char[100];// 在堆上分配,返回首元素的地址
3.  char a1[] = "abc"; 相当于在栈顶分配4个字节,分别放上a,b,c,\0,等价于char a1 ={'a','b','c','\0'};
4.  char* pa = "abc"; 分析一下就知道,pa是char指针,"abc"是一个文本字符串,显然类型不吻合,需要适配.可认为编译器做了下面的事情：在常量区分配4个字节,分别放上a,b,c,\0,然后把a的地址返回给pa.
  注意：文本字符串放在常量区,是不可修改的,试图修改,运行异常.那么在思考一下,既然右边是const,而pa并没有限定为const char*,按道理赋值失败.为什么可以成功?
  可以认为在C语言中,到处充斥着这样的代码.为了兼容,必须允许.但是,我们应该写const char* pa ="abc"; 这样的话,试图修改pa的内容,编译报错.
5.  char a1[] = "abc", 等价于char a1[] = {'a','b','c','\0',}; strlen(a1)等于3,长度不包括'\0'
 假如这样写 char a1[] = {'a','b','c',}; strlen(a1)是多少? 答案不确定,因为strlen一直找到'\0'才end.
6.   char a1[] = "abc"; 下面的结果分别是什么?
	<pre>
	  cout<<&a1[0]<<endl;
	  cout<<a1<<endl;
  </pre>
  输出相同,都是数组元素的第一个地址.
7.  char* pa = "abc"; 下面的结果分别是什么?
	<pre>
	  cout<<&pa<<endl;
	  cout<<&pa[0]<<endl;
	  cout<<pa<<endl;
	</pre>
第一行输出pa在栈上的地址,第二行和第三行输出相同,都是首地址.pa是指针,就是指向首个元素的地址.
8.  char a1[5]; 数组名是个指针常量,不能修改指向.
9.  char* pa = "abc"; 可认为pa是个指向常量的指针.
